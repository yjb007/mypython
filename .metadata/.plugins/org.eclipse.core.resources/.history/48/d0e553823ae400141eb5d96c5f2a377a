#! /usr/bin/env python
#_*_ coding:utf-8 _*_

from file import demo
from __builtin__ import dict
from random import random
import code
from test.test_hashlib import HashLibTestCase
import hashlib


reload(demo)

if __name__ == '__main__':
    demo.Foo()
else:
    print 'no'


print __file__
print __doc__
print __name__

def foo(name, action = '砍柴', where = '北京'):
    print name, '去', where, action
    
foo('张三', '吃饭', '上海')
foo('李四')
foo('王五', action = '上网')
foo('六六', action = '上网' , where='广州')

def show(*agrv):
    for i in agrv:
        print i
show(1,2,3,4,5)
#传参是不确定的多个参数

def show1(agrv):
    for item in agrv:
        print item
show1([1,2,3,4,5])
#传参是列表

def show2(**agrv):
    for item in agrv.items():
        print item
        
dict={'k1':123, 'k2':'yjb','k3':'张三'}
print dict
show2(**dict)
show2(name='zhangsan', age=24)
#传参是字典



def login(username):
    if username == 'alex':
        return 'OK'
    else:
        return 'NO'
#return返回值
       
def detail(username): 
    print username, 'your money is 5555'
        
# if __name__ =='__main__':
#     user = raw_input('please input your name:')
#     res = login(user)
#     if res == 'OK':
#         detail(user)
#     else:
#         print 'NO MONEY'
    
    
def xxx():
    yield 1
    yield 2
    yield 3     
    yield 4   
    yield 5   

re = xxx()         
print re
#yield是生成器，可以不占用内存
for item in re:
    print item
    
    
def AlexReadlines():
    seek = 0 #变量seek
    while True:
        with open('E:/tmp.txt','rb') as f: #这样定义就不用f.close()了
            f.seek(seek)  #定位到位置0
            data = f.readline() #读取文件
            if data: #判断data是否存在
                seek = f.tell() #重新定义seek的位置，f.tell()定位出现在的文件的位置，为下次读取做准备
                yield data #将data保存到yield中,逐行读取并保存到data
            else:
                return  #return会退出整个脚本
  
print AlexReadlines() #打印出的是生成器
  
for item in AlexReadlines():
    print item,

#可用作线程池，迭代效果比较好
#一般函数只有函数执行完毕后才能返回，中间状态外界不知道
#yield可以让函数执行的中间过程的状态被外界所知         
    

    
result = 'false' if 1>3 else 'true'
print result
#三元运算符

def plus(x,y):
    return x+y
print plus(13, 34)

tmp = lambda x,y,z:x+y*z-x
print tmp(1,2,3)
#lambda运算符，匿名函数

print map(lambda x:x**2, range(10))

a = []
# help(a)
# help(dir())
print dir(a)
print type(a)
print vars() 

print abs(-9)     
#求绝对值

print cmp(3,3)
#比较大小

print bool(-1)
#只有0是假，其余都是真


print divmod(5, 2)
#求余数和商

print max(8,6,10)
print max([1,2,3,4,5,6,7])
print min(1,2,3,4,5,6)
print min([1,4,5,7,8,0,-4])
#取最大值,和最小值

print sum([1,2,3,4,5,6])
#求和

print pow(3, 4)
#3**4指数

print len('dsfsdf')
#字符的长度

print all([1,2,3,4,5,6])
#遍历所有元素，如果有0则为假，其余都是真

print any([1,2,3,4,5,6,0])
#遍历所有元素，如果有一个是真，则是真

print chr(66)
#根据asicc码查看字符

print ord('a')
print ord('G')
#查看字符的asicc码

print hex(2)
print bin(2)
print oct(2)
#转换成16进制，2进制，8进制

print range(5)
print xrange(5)
#打印一个数字列表
#xrange是一个生成器，减少内存占用

li = ['手表','汽车','房子']
for i in li:
    print i
    
for item in enumerate(li,1):
    print item[0],item[1]
#打印列表，并表示出序列号，1是起始序列值
#item[0],item[1]表示打印出第一列和第二列

for k,v in enumerate([1,2,3,4]):
    print k,v
#给列表排序加上序列号

s = 'i am {0} {1}'
print s.format('alex', 'xxx')
#占位符用法


alex = 'xx'
xxx = 'XXXX'
print  'i am %s %s'  %(alex, xxx)

def Function(arg):
    print arg
    
Function('yujianbo')




li = [11,22,33,44]
tmp = []
for item in li:
    tmp.append(item + 100)  
print tmp

###############################################
def yyy(arg):
    return arg + 100

li = [11,22,33,44]
tmp = []
for item in li:
    tmp.append(yyy(item))
  
print tmp
##########################

def yyy(arg):
    return arg + 100
tmp = map(yyy, li)
print tmp
#map函数，参数第一个跟函数名，后面跟需要遍历列表等，map将执行结果追加到一个列表里面

li = [11,22,33,44]
tmp = map(lambda arg:arg+100,li)
print tmp

#map对一个列表进行遍历，然后交给前面的函数进行处理，结果保存到一个列表里面

li = [11,22,33,44]
def fil(arg):
    if arg >= 22:
        return True
    else:
        return False

tmp = filter(fil, li)
print tmp
#filter过滤参数，只将过滤结果为true的函数处理结果放到新的列表中

li = [11,22,33,44]
tmp = reduce(lambda x,y:x+y, li)
print tmp
#x+y累加，x*y累乘，必须要接受两个参数下x，y

x = [1,2,3,4,5]
y = [5,6,7,8,9]
z = [3,5,7,9,0]
print zip(x,y,z)
#竖向成新列表

a = '8*8'
print eval(a)
#直接运算字符串运行，shell中也有类似的



tmp = 'mysqlhelper'
model = __import__(tmp)
model.count()
#反射，通过字符串模式导入模块，可以方便切换



tmp = 'mysqlhelper'
func = 'count'
model = __import__(tmp)
ggg = getattr(model, func)
print ggg()
#通过字符串模式导入函数，需要先找到函数getattr

import random
print random.random()
print random.random()*10
#生成0-1之间的随机数
print random.randint(1,5)
#生成1-5间的整形随机数

print random.randrange(1,3)
#生成1和2，不会生成3，整形

print random.randint(100000,999999)
#生成6位随机数

code = []
for i in range(6):
    if i == random.randint(1,5):
        code.append(str(random.randint(1,5))) 
    else:
        tmp = random.randint(65,90)
        code.append(chr(tmp))
print code
print ''.join(code)

#生成六位随机数，数字字符混合
#列表转字符串，非常有用，''.join(code)

import hashlib

hash = hashlib.md5()
hash.update('admin')
print hash.hexdigest()
print hash.digest()

#md5加密


import pickle

li = ['111','222','333','444']

dumped = pickle.dumps(li)
print dumped
print type(dumped)
#序列化一个列表,也可以序列化字典，类等，变成字符串，才能存到硬盘，

loaded = pickle.loads(dumped)
print loaded
print type(loaded)

#反序列化一个字符串，读到内存中

pickle.dump(li, open('D:/tmp.pk', 'wb'))
#将序列化结果保存到硬盘中

result = pickle.load(open('D:/tmp.pk','rb'))
print result
#将硬盘中的序列化文件进行反序列化

###################################################################

import json
name_dict = {'name':'yujianbo','age':24}
dumped = json.dumps(name_dict)
print dumped
#json的序列化

loaded = json.loads(dumped)
print loaded
print type(loaded)



with open('D:/tmp1.pk','wb') as f1:
    json.dump(name_dict,f1)

with open('D:/tmp1.pk','rb') as f2:
    result = json.load(f2)
print result

#json的序列化和反序列化

#pickle只是python用的格式，json所有程序都支持
#列表的序列化和反序列化，一般用在两个python程序之间进行数据交换










import re

res1 = re.match('\d+', '123asd231asdc12eadqwd')
res2 = re.search('\d+', '123asd231asdc12eadqwd')
print res1
print res2
























































      









































































































































